> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/Huangsh2017Come-on/p/7896578.html)

目前在中文网上能搜索到的绝大部分关于装饰器的教程，都在讲如何装饰一个普通的函数。本文介绍如何使用 Python 的装饰器装饰一个类的方法，同时在装饰器函数中调用类里面的其他方法。本文以捕获一个方法的异常为例来进行说明。

有一个类 Test, 它的结构如下：

![](https://images2018.cnblogs.com/blog/1089271/201711/1089271-20171125214044984-1437768429.png)

在类中有一个方法`read_value()`，这个方法在多个地方被调用。由于某些原因，方法`read_value`有可能随机抛出 Exception 导致程序崩溃。所以需要对整个方法做`try ... except`处理。最丑陋的做法如下面的代码所示：

![](https://images2018.cnblogs.com/blog/1089271/201711/1089271-20171125214322359-30526409.png)

这样写虽然可以解决问题，但是代码不 Pythonic。

使用装饰器来解决这个问题，装饰器函数应该写在类里面还是类外面呢？答案是，写在类外面。那么既然写在类外面，如何调用这个类的其他方法呢？

首先写出一个最常见的处理异常的装饰器：

![](https://images2018.cnblogs.com/blog/1089271/201711/1089271-20171125214503093-1919216848.png)

这种写法，确实可以捕获到`origin_func()`的异常，但是如果在发生异常的时候，需要调用类里面的另一个方法来处理异常，这又应该怎么办？答案是给 wrapper 增加一个参数：self.

![](https://images2018.cnblogs.com/blog/1089271/201711/1089271-20171125214624156-475902386.png)

只需要修改装饰器**定义**的部分，使用装饰器的地方完全不需要做修改。

![](https://images2018.cnblogs.com/blog/1089271/201711/1089271-20171125214653000-2098770806.png)

 ![](https://images2018.cnblogs.com/blog/1089271/201711/1089271-20171125214707796-953232756.png)

通过添加一个 self 参数，类外面的装饰器就可以直接使用类里面的各种方法，也可以直接使用类的属性。以上就是外部函数装饰类里面方法的简单案例